---
title: "run in bioinfo"
author: "Emmerson Wilson"
date: "2024-08-27"
output: html_document
---

```{r}
pacman::p_load(
  tidyverse,
  deSolve)
```

# model
## structure
```{r}
lv <- function(times, state, parms) {
  with(as.list(c(state, parms)), {
# moose
    Consumption    <- ((a * Pyoung)/(1 + a * h * Pyoung)) * Moose
    Death <- lM * (Moose^2)
    
    # palatable 
    GrowthPy <- rP * Pyoung * (1 - (Pyoung + Pmature + alphaUPy * Unpal)/kPy)
    NewSeed <- s * Pmature
    GrowthPm <- rP * Pmature * (1 - (Pyoung + Pmature + alphaUPm * Unpal)/kPm)
    Ageing <- if(times <= 1/g) 0 else g * Pyoung  
    DeathPm <- lPm * Pmature
    
    # unpalatable
    GrowthU <- rU * Unpal * (1 - (alphaPyU * Pyoung + alphaPmU * Pmature + Unpal)/kU)
    DeathU <- lU * Unpal

    # odes
    dMoose  <- Consumption*e - Death 
    dPyoung <- GrowthPy + NewSeed - Consumption - Ageing
    dPmature <- GrowthPm + Ageing - DeathPm
    dUnpal <- GrowthU - DeathU
    

    list(c(dMoose, dPyoung, dPmature, dUnpal))
  })
}
```

## parameters
```{r}
parms  <- c(a = 0.9985, #from Lunberg and Danelle 1990
            h = 0.0223, # 1/max intake in Mg per Mg moose per year (similar to handling time of Lunberg and Denelle)
            e = 0.02, #0.02 leads to max reasonable stable moose pop, prefer 0.01
            lM = 0.2451, # 1/lifespan
            rP = 0.2,
            s = 0.011,
            alphaUPy = 0.001,
            alphaUPm = 0.0001, # should have almost no effect
            kPy = 2000,
            kPm = 85000, # includes only live veg
            g = 0.133, # 1/time to reach 3m
            lPm = 0.01,
            rU = 0.4,
            alphaPyU = 0.003, # less than alphaPmU, but more than alphaUpy
            alphaPmU = 0.0065, # level so that kPm*alpha < kU, so that some upalatable species do persist, as seen in field
            kU = 1000,
            lU = 0.05)
```

## initial conditions
```{r}
time_vec1 <- seq(from = 1, to = 600, length.out = 600)

y_0 <- c(Moose =2, Pyoung = 1, Pmature = 0, Unpal = 100)
```

## extinction
```{r}
eps <- 1e-2
## event triggered if state variable <= eps
eventfun <- function(times, y, parms) {
  y[which(y<eps | y<0)] <- 0 
  return(y)
}
```

## run model
```{r}
#with extinction
# out1 <- ode(y = state, times = time_vec1, func = lv, parms = parms, method = "lsoda", rootfun = rootfun, events = list(func = eventfun, root = TRUE))

# with Alex's code
# Run ode - supply the whole time vector as event times
out2 <- ode(y = y_0, times = time_vec1, func = lv, parms = parms, events=list(func = eventfun, time = time_vec1))
```

# ranges

## initial conditions
```{r}
# make dataframe with sequence of initial conditions to sample over
# always starting from no mature and some level of unpal
# smallest values 0 for both, moose up to 5 Mg moose, and 4000 Py

n_i <- 30

M_init <- seq(0, 6, length.out = n_i)
Py_init <- seq(0, 500, length.out = n_i) # determine reasonable maximum young palatable biomass left after disturbance
Pm_init <- rep(0, n_i)
U_init <- rep(100, n_i)

init_seq <- data.frame(Moose=rep(M_init, each = n_i), Pyoung = rep(Py_init, n_i), Pmature = rep(Pm_init,n_i), Unpal = rep(U_init,n_i))

y_0d <- split(as.matrix(init_seq), row(init_seq)) %>% 
  lapply(setNames, nm = c("Moose", "Pyoung", "Pmature", "Unpal"))
```

## parameters
```{r}
# make datafram with distribution of parameters

LVlow <-  c(0.996, #a
            0.0207933, # h
            0.01, #e
            0.1536332, # lM
            0.1, #rP
            0.0088, #s
            0.0005, #alphaUPy
            0.000, #alphaUPm
            400, #kPy
            20000, # kPm
            0.1, # g
            0.005, #lPm
            0.3,#rU
            0.002, # alphaPyU
            0.004, # alphaPmU
            300, #kU
            0.05) #lU

LVhigh <-  c(1.005, #a
            0.038735, # h
            0.03, #e
            0.3, # lM
            0.3, #rP
            0.053, #s
            0.0019, #alphaUPy
            0.0002, #alphaUPm
            8000, #kPy
            200000, # kPm
            0.2, # g
            0.06, #lPm
            0.6,#rU
            0.0039, # alphaPyU
            0.008, # alphaPmU
            2500, #kU
            0.168) #lU

param_dist <- data.frame(min = LVlow, max = LVhigh, mean = parms)

#select from parameter space randomly 100 time (for now)
library(truncnorm)
```

### how many samples
number of parameter combos vs number recovered
```{r}
## for n samples of random parameter combos vs n recover
# will take a long time so do on computer at school

n_p_list <- as.list(rgamma(100, 4, 0.0175), 1000)

rep_over_n_param_samples <- function (n_param) {
  
# make n random combinations of paramaters
  n_p <- n_param
  for(i in rownames(param_dist)){
    sampled_param[[i]] <- signif(rtruncnorm(n=n_p, a=param_dist[[i,1]], b=param_dist[[i,2]], mean=param_dist[[i,3]]), 4)
  }
  
  sampled_param_list <-  split(as.matrix(as.data.frame(sampled_param)), row(as.data.frame(sampled_param))) %>% 
    lapply(setNames, nm = names(parms))
  
  sampled_param_list_final <- list()
  sampled_param_list_final[[1]] <- parms
  sampled_param_list_final[[2]] <- parms
  sampled_param_list_final[[1]] <- sampled_param_list[[1]]
  
  
  
  # remove combinations that don't meet assumptions (around competative effects, growth rates, carrying capacities, and death rates)
  
  # relative growth rate
  sampled_param_list2 <-  sampled_param_list[sapply(sampled_param_list, `[`, 'rP') < sapply(sampled_param_list, `[`, 'rU')]
  
  # competative effects
  sampled_param_list3 <-  sampled_param_list2[sapply(sampled_param_list2, `[`, 'alphaUPm') < sapply(sampled_param_list2, `[`, 'alphaUPy') & sapply(sampled_param_list2, `[`, 'alphaUPy') < sapply(sampled_param_list2, `[`, 'alphaPyU') & sapply(sampled_param_list2, `[`, 'alphaPyU') < sapply(sampled_param_list2, `[`, 'alphaPmU')]
  
  # carrying capacities
  sampled_param_list4 <-  sampled_param_list3[sapply(sampled_param_list3, `[`, 'kU') < sapply(sampled_param_list3, `[`, 'kPy') & sapply(sampled_param_list3, `[`, 'kPy') < sapply(sampled_param_list3, `[`, 'kPm')]
  
  # loss
  sampled_param_list_final <-  sampled_param_list4[sapply(sampled_param_list4, `[`, 'lPm') < sapply(sampled_param_list4, `[`, 'lU')]

# combine with initial values (constant) 
  args <- expand.grid(
    parameters=sampled_param_list_final,
    initial_conditions=y_0d) 
  args_id <- args %>% mutate(id = seq(1, nrow(args), by = 1))
  list2env(args, envir=.GlobalEnv)
  
# run ode
  args$output <- mapply(ode_reps, parameters, initial_conditions, SIMPLIFY = F)
  
# get total number of recovered
  names(args$output) <- seq(1, nrow(args_id), by = 1)
  
  args_less <- purrr::discard(args$output, ~nrow(.) < 3)
  arg_less_last <- lapply(args_less,tail, 1, SIMPLIFY = T) 
  names(arg_less_last) <- paste(names(arg_less_last), ifelse(map(arg_less_last, pluck, 4) > 0, "forest", "grassland"))
  
  g_vs_f <- data.frame(id = parse_number(names(arg_less_last)), g_or_f = str_remove_all(names(arg_less_last), "[:digit:]")) %>% 
    left_join(args_id) %>% 
    mutate(Moose = unlist(map(initial_conditions, pluck, 1)), By = unlist(map(initial_conditions, pluck, 2))) %>% 
    select(!c(1,3,4))
  
  n_g_vs_f <- g_vs_f %>% 
    group_by(as.factor(Moose), as.factor(By), as.factor(g_or_f), .drop=FALSE) %>% 
    count(.drop=FALSE) %>% 
    ungroup() %>% 
    mutate(Moose = as.numeric(as.character(`as.factor(Moose)`))) %>% 
    mutate(By = as.numeric(as.character(`as.factor(By)`))) %>% 
    rename(g_or_f = `as.factor(g_or_f)`) %>% 
    select(c(3:6))
  
  percent_rec <- sum(filter(n_g_vs_f, g_or_f == " forest")$n)/sum(n_g_vs_f$n)
  
  return(percent_rec)
}

n_p_recoveries <- lapply(n_p_list, rep_over_n_param_samples)

plot(n_p_list, n_p_recoveries)
```

### list for heatmap
```{r}
sampled_param <- list()

n_p <- 50 # may change

for(i in rownames(param_dist)){
sampled_param[[i]] <- signif(rtruncnorm(n=n_p, a=param_dist[[i,1]], b=param_dist[[i,2]], mean=param_dist[[i,3]]), 4)
}

sampled_param_list <-  split(as.matrix(as.data.frame(sampled_param)), row(as.data.frame(sampled_param))) %>% 
  lapply(setNames, nm = names(parms))

sampled_param_list_final <- list()
sampled_param_list_final[[1]] <- parms
sampled_param_list_final[[2]] <- parms
sampled_param_list_final[[1]] <- sampled_param_list[[1]]

# remove combinations that don't meet assumptions (around competative effects, growth rates, carrying capacities, and death rates)

# relative growth rate
sampled_param_list2 <-  sampled_param_list[sapply(sampled_param_list, `[`, 'rP') < sapply(sampled_param_list, `[`, 'rU')]

# competative effects
sampled_param_list3 <-  sampled_param_list2[sapply(sampled_param_list2, `[`, 'alphaUPm') < sapply(sampled_param_list2, `[`, 'alphaUPy') & sapply(sampled_param_list2, `[`, 'alphaUPy') < sapply(sampled_param_list2, `[`, 'alphaPyU') & sapply(sampled_param_list2, `[`, 'alphaPyU') < sapply(sampled_param_list2, `[`, 'alphaPmU')]

# carrying capacities
sampled_param_list4 <-  sampled_param_list3[sapply(sampled_param_list3, `[`, 'kU') < sapply(sampled_param_list3, `[`, 'kPy') & sapply(sampled_param_list3, `[`, 'kPy') < sapply(sampled_param_list3, `[`, 'kPm')]

# loss
sampled_param_list_final <-  sampled_param_list4[sapply(sampled_param_list4, `[`, 'lPm') < sapply(sampled_param_list4, `[`, 'lU')]
```


# heatmap
```{r}
pacman::p_load(
  tidyverse,
  deSolve)
# make ode into function where parameters and initial conditions can be used
out_end <- list()                     
out <- list()        

ode_reps <- function(parameters, initial_conditions) {
  out <- ode(y = initial_conditions, times = time_vec1, func = lv, parms = parameters, events=list(func = eventfun, time = time_vec1))
}

# run over params and init conditions
args <- expand.grid(
  parameters=sampled_param_list_final,
  initial_conditions=y_0d) 
args_id <- args %>% mutate(id = seq(1, nrow(args), by = 1))
list2env(args, envir=.GlobalEnv)
args$output <- mapply(ode_reps, parameters, initial_conditions, SIMPLIFY = F)
names(args$output) <- seq(1, nrow(args_id), by = 1)

args_less <- purrr::discard(args$output, ~nrow(.) < 3)
arg_removed <- purrr::keep(args$output, ~nrow(.) < 3)


# or look at coefficient of variation for last 25 years
cv <- function(x)  sd(x)/mean(x)

# select only one column of 
arg_last_25M_l <- lapply(lapply(args_less,tail, 25, SIMPLIFY = T), "[", , 'Moose')
arg_last_25Py_l <- lapply(lapply(args_less,tail, 25, SIMPLIFY = T), "[", , 'Pyoung')
arg_last_25Pm_l <- lapply(lapply(args_less,tail, 25, SIMPLIFY = T), "[", , 'Pmature')
arg_last_25U_l <- lapply(lapply(args_less,tail, 25, SIMPLIFY = T), "[", , 'Unpal')

arg_last_25_l <- list(arg_last_25M_l, arg_last_25Py_l, arg_last_25Pm_l, arg_last_25U_l)

arg_cv_l <- lapply(arg_last_25_l, lapply, cv)

library(rlist)

# return any that are above some cut off (10e-7 for now)
arg_cv_less_l <- lapply(arg_cv_l, list.filter, . >= 10e-7)

names(arg_cv_less_l[[1]])

arg_cv_less_cv <- args_less[ ! names(args_less) %in% names(arg_cv_less_l[[1]]) ]

# get final stocks from remaining simulations
arg_less_last <- lapply(arg_cv_less_cv,tail, 1, SIMPLIFY = T) 

# how to make this info a heat map

# if pmature = 0, and/or Unpal ≠ 0 then grassland
# if pmature ≠ 0 then forest

names(arg_less_last) <- paste(names(arg_less_last), ifelse(map(arg_less_last, pluck, 4) > 0, "forest", "grassland"))

g_vs_f <- data.frame(id = parse_number(names(arg_less_last)), g_or_f = str_remove_all(names(arg_less_last), "[:digit:]")) %>% 
  left_join(args_id) %>% 
  mutate(Moose = unlist(map(initial_conditions, pluck, 1)), By = unlist(map(initial_conditions, pluck, 2))) %>% 
  select(!c(1,3,4))

n_g_vs_f <- g_vs_f %>% 
  group_by(as.factor(Moose), as.factor(By), as.factor(g_or_f), .drop=FALSE) %>% 
  count(.drop=FALSE) %>% 
  ungroup() %>% 
  mutate(Moose = as.numeric(as.character(`as.factor(Moose)`))) %>% 
  mutate(By = as.numeric(as.character(`as.factor(By)`))) %>% 
  rename(g_or_f = `as.factor(g_or_f)`) %>% 
  select(c(3:6))

# into %

n_f <- subset(n_g_vs_f, g_or_f == " forest") %>% 
  mutate(percent_recover = (n/length(sampled_param_list_final))*100)

# marking 50/50

library(viridis)

n_f2 <- n_f %>% 
  filter(percent_recover >= 50) %>% 
  group_by(Moose,  .drop=FALSE) %>% 
  filter(By == min(By)) %>%
  mutate(Moose = Moose - 0.2068966/2, By = By - 17.24138/2	) %>%
  arrange(Moose)

n_f2 <- n_f2 %>% bind_rows(n_f2[nrow(n_f2), ] %>% mutate(Moose = Moose))
n_f2

heatmap_moose_By <- ggplot() +
  geom_tile(data = n_f, aes(x = Moose, y = By, fill = percent_recover)) +
  geom_step(data = n_f2, aes(x = Moose, y = By), size = 0.5) +
  scale_fill_viridis_c() +
  labs(x = "Moose biomass (Metric tons)", y = "Young palatable plant biomass (Metric tons)", fill = "Percent\nrecovered") +
  theme_classic() +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_continuous(expand = c(0,0))
```



